colour = point_de_vue,
size=count))+
geom_jitter(width = 0.3,alpha=0.7)+
scale_size_continuous(range = c(3,8))+
scale_color_d3()+
theme_light()+
labs(title="Evidence Gap Map\nObjets d'étude, méthodologies et points de vue",
y="Objet d'étude",
x="Méthodoloie",
size="Décompte",
colour = "Point de vue")+
theme(legend.position = "bottom",
legend.box = "vertical",
axis.text.x = element_text(size=8),
strip.background = element_blank(),
strip.text.x = element_blank(),
panel.spacing = unit(0, "cm"),
panel.grid.major = element_blank())+
facet_grid(objet_etudie~cadre_recherche,
scales="free",space="free")+
guides(size = guide_legend(ncol=6,
title.position = "top"),
colour = guide_legend(ncol=3,
title.position = "top",
override.aes = list(size=3)))
ggsave(filename = file.path(path,"graphs/egm_objet_methodo_pdv.png"),
width = 23,
height = 23,
units = "cm",
last_plot())
ggsave(filename = file.path(path,"graphs/egm_objet_methodo_pdv.png"),
width = 30,
height = 23,
units = "cm",
last_plot())
# Evidence map 3
# Version objet, impact, point de vue
evidence_map3 = data %>%
select(objet_etudie,cadre_recherche,point_de_vue) %>%
group_by(objet_etudie,cadre_recherche,point_de_vue) %>%
summarise(count = n()) %>%
mutate(cadre_recherche=str_replace_all(cadre_recherche,
" ","\n"))
ggplot(evidence_map3[!is.na(evidence_map3$point_de_vue),],
aes(y=objet_etudie,
x=cadre_recherche,
colour = point_de_vue,
size=count))+
geom_jitter(width = 0.3,alpha=0.7)+
scale_size_continuous(range = c(3,8))+
scale_color_d3()+
theme_light()+
labs(title="Evidence Gap Map\nObjets d'étude, méthodologies et points de vue",
y="Objet d'étude",
x="Méthodoloie",
size="Décompte",
colour = "Point de vue")+
theme(legend.position = "bottom",
legend.box = "vertical",
axis.text.x = element_text(size=8),
strip.background = element_blank(),
strip.text.x = element_blank(),
panel.spacing = unit(0, "cm"),
panel.grid.major = element_blank())+
facet_grid(objet_etudie~cadre_recherche,
scales="free",space="free")+
guides(size = guide_legend(ncol=6,
title.position = "top"),
colour = guide_legend(ncol=3,
title.position = "top",
override.aes = list(size=3)))
ggsave(filename = file.path(path,"graphs/egm_objet_methodo_pdv.png"),
width = 30,
height = 23,
units = "cm",
last_plot())
ggplot(evidence_map3[!is.na(evidence_map3$point_de_vue),],
aes(y=objet_etudie,
x=cadre_recherche,
colour = point_de_vue,
size=count))+
geom_jitter(width = 0.3,alpha=0.7)+
scale_size_continuous(range = c(3,8))+
scale_color_d3()+
theme_light()+
labs(title="Evidence Gap Map\nObjets d'étude, méthodologies et points de vue",
y="Objet d'étude",
x="\nMéthodologie",
size="Décompte",
colour = "Point de vue")+
theme(legend.position = "bottom",
legend.box = "vertical",
axis.text.x = element_text(size=8),
strip.background = element_blank(),
strip.text.x = element_blank(),
panel.spacing = unit(0, "cm"),
panel.grid.major = element_blank())+
facet_grid(objet_etudie~cadre_recherche,
scales="free",space="free")+
guides(size = guide_legend(ncol=6,
title.position = "top"),
colour = guide_legend(ncol=3,
title.position = "top",
override.aes = list(size=3)))
ggsave(filename = file.path(path,"graphs/egm_objet_methodo_pdv.png"),
width = 30,
height = 23,
units = "cm",
last_plot())
library(ggalluvial)
install.packages("ggalluvial")
library(ggalluvial)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise_all(count())
summarise_all(count
)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise_all(count)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise_all(n)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise_all(n())
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise(n())
View(data_alluvial)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
group_by(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise(n())
View(data_alluvial)
ggplot(data,
aes_string(y = "n()",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(aes(fill = Class),
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
coord_flip() +
ggtitle("Titanic survival by class and sex")
ggplot(data,
aes_string(y = "n()",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(aes(),
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
coord_flip() +
ggtitle("Titanic survival by class and sex")
ggplot(data,
aes_string(y = "n()",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
coord_flip() +
ggtitle("Titanic survival by class and sex")
ggplot(data_alluvial,
aes_string(y = "n()",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
coord_flip() +
ggtitle("Titanic survival by class and sex")
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
group_by(objet_etudie, variable_performance,
point_de_vue,cadre_recherche) %>%
summarise(n()) %>%
rename("n"="n()")
ggplot(data_alluvial,
aes_string(y = "n",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
coord_flip() +
ggtitle("Titanic survival by class and sex")
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
ggtitle("Titanic survival by class and sex")
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
ggtitle("Titanic survival by class and sex")
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
# geom_stratum(width = 1/8, reverse = FALSE) +
geom_text(stat = "stratum", aes(label = after_stat(stratum)),
reverse = FALSE) +
# scale_x_continuous(breaks = 1:3, labels = c("Survived", "Sex", "Class")) +
ggtitle("Titanic survival by class and sex")
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum()
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8)
ggplot(data_alluvial,
aes_string(y = "n",
axis1 = "objet_etudie",
axis2 = "variable_performance",
axis3 = "point_de_vue",
axis4 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8)
# 04. ALLUVIAL GRAPH ------------------------------------------------------
data_alluvial <- data %>%
select(objet_etudie,
point_de_vue,cadre_recherche) %>%
group_by(objet_etudie,
point_de_vue,cadre_recherche) %>%
summarise(n()) %>%
rename("n"="n()")
ggplot(data_alluvial,
aes_string(y = "n",
axis1 = "objet_etudie",
axis2 = "point_de_vue",
axis3 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE) +
guides(fill = FALSE) +
geom_stratum(width = 1/8)
ggplot(data_alluvial,
aes_string(y = "n",
axis1 = "objet_etudie",
axis2 = "point_de_vue",
axis3 = "cadre_recherche")) +
geom_alluvium(
width = 0, knot.pos = 0, reverse = FALSE)
ggplot(data_alluvial,
aes_string(y = "n",
axis1 = "objet_etudie",
axis2 = "point_de_vue",
axis3 = "cadre_recherche")) +
geom_alluvium() +
guides(fill = FALSE) +
geom_stratum(width = 1/8)
?replicate
seq(rnorm(n=G, mean=0, sd=1),each=N_g)
G=5
N_g=30
seq(rnorm(n=G, mean=0, sd=1),each=N_g)
?seq
rep(rnorm(n=G, mean=0, sd=1),each=N_g)
as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
dgp_homoskedastic <- function(G,N_g=30,
b_0 = 0,
b_1=1){
# FUNCTION DESCRIPTION   - - - - - - - -
# This function codes for the data-generating process as defined in Cameron, Gelbach and Miller (2008).
# Errors are independent across clusters but correlated within clusters
# Errors are normally distributed and homoskedastic.
# We assume same number of units N_g per cluster
# DRAWING DATA - - - - - - - - - - - - -
## Error part
# Correlation of errors within each cluster
e_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of error
e_ig = rnorm(n=N_g*G, mean=0, sd=1)
## Covariates part
# Correlation of covariates within each cluster
z_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of covariates
z_ig = rnorm(n=N_g*G, mean=0, sd=1)
# GENERATING OUTCOME VARIABLES - - - - -
u_ig = e_g + e_ig
x_ig = z_g + z_ig
y_ig = b_0 + b_1*x_ig + u_ig
# OUTPUT - - - - - - - - - - - - - - - -
return(data.frame("y"=y_ig,
"x"=x_ig,
"g"=rep(seq(1:G), each=N_g)))
}
dgp_heteroskedastic <- function(G,N_g=30,
b_0 = 1,
b_1=1){
# FUNCTION DESCRIPTION   - - - - - - - -
# This function codes for the data-generating process as defined in Cameron, Gelbach and Miller (2008).
# Errors are independent across clusters but correlated within clusters
# Errors are normally distributed and heteroskedastic.
# We assume same number of units N_g per cluster
# DRAWING DATA - - - - - - - - - - - - -
## Covariates part
# Correlation of covariates within each cluster
z_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of covariates
z_ig = rnorm(n=N_g*G, mean=0, sd=1)
## Error part
# Correlation of errors within each cluster
e_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of error: heteroskedastic
e_ig = rnorm(n=N_g*G, mean=0, sd=9 * (z_g + z_ig)^2)
# GENERATING OUTCOME VARIABLES - - - - -
u_ig = e_g + e_ig
x_ig = z_g + z_ig
y_ig = b_0 + b_1*x_ig + u_ig
# OUTPUT - - - - - - - - - - - - - - - -
return(data.frame("y"=y_ig,
"x"=x_ig,
"g"=rep(seq(1:G), each=N_g)))
}
dgp_homoskedastic_skewed <- function(G,N_g=30,
b_0 = 0,
b_1=1,
mu,sigma){
# FUNCTION DESCRIPTION   - - - - - - - -
# This function codes for the data-generating process as defined in Cameron, Gelbach and Miller (2008).
# Errors are independent across clusters but correlated within clusters
# Errors are normally distributed and homoskedastic.
# We assume same number of units N_g per cluster
# DRAWING DATA - - - - - - - - - - - - -
## Error part
# Correlation of errors within each cluster
e_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of error
e_ig = rnorm(n=N_g*G, mean=0, sd=1)
## Covariates part
# Correlation of covariates within each cluster
z_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of covariates
z_ig = rnorm(n=N_g*G, mean=0, sd=1)
# GENERATING OUTCOME VARIABLES - - - - -
u_ig = e_g + e_ig
x_ig = exp(mu + sigma(z_g + z_ig))
y_ig = b_0 + b_1*x_ig + u_ig
# OUTPUT - - - - - - - - - - - - - - - -
return(data.frame("y"=y_ig,
"x"=x_ig,
"g"=rep(seq(1:G), each=N_g)))
}
dgp_heteroskedastic_skewed <- function(G,N_g=30,
b_0 = 1,
b_1=1,
mu,
sigma){
# FUNCTION DESCRIPTION   - - - - - - - -
# This function codes for the data-generating process as defined in Cameron, Gelbach and Miller (2008).
# Errors are independent across clusters but correlated within clusters
# Errors are normally distributed and heteroskedastic.
# We assume same number of units N_g per cluster
# DRAWING DATA - - - - - - - - - - - - -
## Covariates part
# Correlation of covariates within each cluster
z_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of covariates
z_ig = rnorm(n=N_g*G, mean=0, sd=1)
## Error part
# Correlation of errors within each cluster
e_g = as.vector(rep(rnorm(n=G, mean=0, sd=1),each=N_g))
# Individual part of error: heteroskedastic
e_ig = rnorm(n=N_g*G, mean=0, sd=9 * (z_g + z_ig)^2)
# GENERATING OUTCOME VARIABLES - - - - -
u_ig = e_g + e_ig
x_ig = exp(mu+sigma*(z_g + z_ig))
y_ig = b_0 + b_1*x_ig + u_ig
# OUTPUT - - - - - - - - - - - - - - - -
return(data.frame("y"=y_ig,
"x"=x_ig,
"g"=rep(seq(1:G), each=N_g)))
}
# 00. LOADING FUNCTIONS & PACKAGES ----------------------------------------
# sets wd as the path in which script is
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source("functions.R")
if(!("clubSandwich"%in%installed.packages()[,'Package'])){
install.packages('clubSandwich')
}
library("clubSandwich")
# 01. results_hoc REPLICATION -------------------------------------------------
# Setting parameters
mCarlo = 10 # Number of Monte Carlo Iteration
bStrap= 399 # Number of Boostrap iterations
clusters = c(5,10 #,15,20,25,30
) # Number of clusters to be tested
N_g = 30 # number of observation per cluster
beta_null = 1
# HOMOSKEDACTIC DGP
# Creating empty list if not yet in the environment
if(!exists("results_hoc")){
results_hoc = list()
}
estimators_wald = c('ols','ols_Bt','crve','crve_Bt','cr3_Bt','cr3',
'resi_Bt','wild_Bt')
G
# Initialising results_hoc storage if empty list
if(length(results_hoc[[paste(G)]])==0){
for(method in estimators_wald){
results_hoc[[paste(G)]][[method]] = list("rejection" = c(),
"wald" = c())
}
} # If not empty we want to add more iterations to improve our accuracy !
it=1
# Random data generation process
data = dgp_homoskedastic(G=G,N_g=N_g)
thresh = qchisq(0.95,df=1) # Significance level for rejection rate
# Estimation of regression:
reg = lm(y~x-1,data=data)
beta_null_b = betaH(data)
# Basic ols variance
wald_OLS = wald(reg)
wald_OLS
# CRVE variance estimator
wald_CRVE = wald(reg, cluster = "CR1",data=data)
wald_CRVE
# CR3 variance estimator
wald_CR3 = wald(reg, cluster = "CR3",data=data)
wald_CR3
# CR3 variance estimator
wald_CR3 = wald(reg, cluster = "CR3",data=data)
wald_CR3
# Restricted beta and associated residuals
restrict = restricted_OLS(data)
data$ur = restrict[['residuals_r']]
beta_r = restrict[['beta_r']]
# Initialisation of storage for monte carlo
boot_ols = c()
boot_crve = c()
boot_cr3 = c()
boot_resi = c()
boot_wild = c()
index_b <- sample(G,G,replace=TRUE)
data_b <- do.call(rbind,lapply(index_b,function(k){
return(data[data$g==k ,])}))
while(length(unique(data_b$g))==1){
index_b <- sample(G,G,replace=TRUE)
data_b <- do.call(rbind,lapply(index_b,function(k){
return(data[data$g==k ,])}))
}
# Estimation of regression:
reg = lm(y~x-1,data=data_b)
wald(reg, beta_null = beta_null_b,data=data_b)
wald(reg, beta_null = beta_null_b,cluster = "CR1",data=data_b)
wald(reg, beta_null = beta_null_b,cluster = "CR3",data=data_b)
wald(reg_re, cluster = "CR1",data=data_r)
# Residuals boostrap
data_r = data.frame(x=data$x,
g=data$g,
y=beta_r*data$x+data_b$ur)
reg_re = lm(y~x-1,data=data_r)
wald(reg_re, cluster = "CR1",data=data_r)
# Wild boostrap
wild_p = rep(sample(c(1,-1), G,
prob = c(0.5,0.5), replace=T),
each=N_g)
data_r2 = data.frame(x=data$x,
g=data$g,
y=beta_r*data$x + wild_p * data$ur)
reg_r2 = lm(y~x-1,data=data_r2)
wald(reg_r2, cluster = "CR1",data=data_r2)
